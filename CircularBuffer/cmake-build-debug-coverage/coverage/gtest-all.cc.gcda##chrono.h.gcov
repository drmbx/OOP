        -:    0:Source:/usr/include/c++/13/bits/chrono.h
        -:    0:Graph:/home/drmbx/CLionProjects/OOP/CircularBuffer/cmake-build-debug-coverage/test/lib/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcno
        -:    0:Data:/home/drmbx/CLionProjects/OOP/CircularBuffer/cmake-build-debug-coverage/test/lib/googletest/CMakeFiles/gtest.dir/src/gtest-all.cc.gcda
        -:    0:Runs:1
        -:    1:// chrono::duration and chrono::time_point -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2008-2023 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file include/bits/chrono.h
        -:   26: *  This is an internal header file, included by other library headers.
        -:   27: *  Do not attempt to use it directly. @headername{chrono}
        -:   28: */
        -:   29:
        -:   30:#ifndef _GLIBCXX_CHRONO_H
        -:   31:#define _GLIBCXX_CHRONO_H 1
        -:   32:
        -:   33:#pragma GCC system_header
        -:   34:
        -:   35:#if __cplusplus >= 201103L
        -:   36:
        -:   37:#include <ratio>
        -:   38:#include <type_traits>
        -:   39:#include <limits>
        -:   40:#include <ctime>
        -:   41:#include <bits/parse_numbers.h> // for literals support.
        -:   42:#if __cplusplus >= 202002L
        -:   43:# include <concepts>
        -:   44:# include <compare>
        -:   45:#endif
        -:   46:
        -:   47:namespace std _GLIBCXX_VISIBILITY(default)
        -:   48:{
        -:   49:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   50:
        -:   51:#if __cplusplus >= 201703L
        -:   52:  namespace filesystem { struct __file_clock; };
        -:   53:#endif
        -:   54:
        -:   55:  namespace chrono
        -:   56:  {
        -:   57:    /// @addtogroup chrono
        -:   58:    /// @{
        -:   59:
        -:   60:    /// `chrono::duration` represents a distance between two points in time
        -:   61:    template<typename _Rep, typename _Period = ratio<1>>
        -:   62:      class duration;
        -:   63:
        -:   64:    /// `chrono::time_point` represents a point in time as measured by a clock
        -:   65:    template<typename _Clock, typename _Dur = typename _Clock::duration>
        -:   66:      class time_point;
        -:   67:    /// @}
        -:   68:  }
        -:   69:
        -:   70:  /// @addtogroup chrono
        -:   71:  /// @{
        -:   72:
        -:   73:  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)
        -:   74:
        -:   75:  /// @cond undocumented
        -:   76:
        -:   77:  template<typename _CT, typename _Period1, typename _Period2, typename = void>
        -:   78:    struct __duration_common_type
        -:   79:    { };
        -:   80:
        -:   81:  template<typename _CT, typename _Period1, typename _Period2>
        -:   82:    struct __duration_common_type<_CT, _Period1, _Period2,
        -:   83:				  __void_t<typename _CT::type>>
        -:   84:    {
        -:   85:    private:
        -:   86:      using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;
        -:   87:      using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;
        -:   88:      using __cr = typename _CT::type;
        -:   89:      using __r = ratio<__gcd_num::value,
        -:   90:			(_Period1::den / __gcd_den::value) * _Period2::den>;
        -:   91:
        -:   92:    public:
        -:   93:      using type = chrono::duration<__cr, typename __r::type>;
        -:   94:    };
        -:   95:
        -:   96:  /// @endcond
        -:   97:
        -:   98:  /// @{
        -:   99:  /// @relates chrono::duration
        -:  100:
        -:  101:  /// Specialization of common_type for chrono::duration types.
        -:  102:  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
        -:  103:    struct common_type<chrono::duration<_Rep1, _Period1>,
        -:  104:		       chrono::duration<_Rep2, _Period2>>
        -:  105:    : __duration_common_type<common_type<_Rep1, _Rep2>,
        -:  106:			     typename _Period1::type,
        -:  107:			     typename _Period2::type>
        -:  108:    { };
        -:  109:
        -:  110:  /// Specialization of common_type for two identical chrono::duration types.
        -:  111:  template<typename _Rep, typename _Period>
        -:  112:    struct common_type<chrono::duration<_Rep, _Period>,
        -:  113:		       chrono::duration<_Rep, _Period>>
        -:  114:    {
        -:  115:      using type = chrono::duration<typename common_type<_Rep>::type,
        -:  116:				    typename _Period::type>;
        -:  117:    };
        -:  118:
        -:  119:  /// Specialization of common_type for one chrono::duration type.
        -:  120:  template<typename _Rep, typename _Period>
        -:  121:    struct common_type<chrono::duration<_Rep, _Period>>
        -:  122:    {
        -:  123:      using type = chrono::duration<typename common_type<_Rep>::type,
        -:  124:				    typename _Period::type>;
        -:  125:    };
        -:  126:  /// @}
        -:  127:
        -:  128:  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)
        -:  129:
        -:  130:  /// @cond undocumented
        -:  131:
        -:  132:  template<typename _CT, typename _Clock, typename = void>
        -:  133:    struct __timepoint_common_type
        -:  134:    { };
        -:  135:
        -:  136:  template<typename _CT, typename _Clock>
        -:  137:    struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>>
        -:  138:    {
        -:  139:      using type = chrono::time_point<_Clock, typename _CT::type>;
        -:  140:    };
        -:  141:
        -:  142:  /// @endcond
        -:  143:
        -:  144:  /// @{
        -:  145:  /// @relates chrono::time_point
        -:  146:
        -:  147:  /// Specialization of common_type for chrono::time_point types.
        -:  148:  template<typename _Clock, typename _Duration1, typename _Duration2>
        -:  149:    struct common_type<chrono::time_point<_Clock, _Duration1>,
        -:  150:		       chrono::time_point<_Clock, _Duration2>>
        -:  151:    : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock>
        -:  152:    { };
        -:  153:
        -:  154:  /// Specialization of common_type for two identical chrono::time_point types.
        -:  155:  template<typename _Clock, typename _Duration>
        -:  156:    struct common_type<chrono::time_point<_Clock, _Duration>,
        -:  157:		       chrono::time_point<_Clock, _Duration>>
        -:  158:    { using type = chrono::time_point<_Clock, _Duration>; };
        -:  159:
        -:  160:  /// Specialization of common_type for one chrono::time_point type.
        -:  161:  template<typename _Clock, typename _Duration>
        -:  162:    struct common_type<chrono::time_point<_Clock, _Duration>>
        -:  163:    { using type = chrono::time_point<_Clock, _Duration>; };
        -:  164:  /// @}
        -:  165:
        -:  166:  /// @} group chrono
        -:  167:
        -:  168:  namespace chrono
        -:  169:  {
        -:  170:    /// @addtogroup chrono
        -:  171:    /// @{
        -:  172:
        -:  173:    /// @cond undocumented
        -:  174:
        -:  175:    // Primary template for duration_cast impl.
        -:  176:    template<typename _ToDur, typename _CF, typename _CR,
        -:  177:	     bool _NumIsOne = false, bool _DenIsOne = false>
        -:  178:      struct __duration_cast_impl
        -:  179:      {
        -:  180:	template<typename _Rep, typename _Period>
        -:  181:	  static constexpr _ToDur
        -:  182:	  __cast(const duration<_Rep, _Period>& __d)
        -:  183:	  {
        -:  184:	    typedef typename _ToDur::rep			__to_rep;
        -:  185:	    return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
        -:  186:	      * static_cast<_CR>(_CF::num)
        -:  187:	      / static_cast<_CR>(_CF::den)));
        -:  188:	  }
        -:  189:      };
        -:  190:
        -:  191:    template<typename _ToDur, typename _CF, typename _CR>
        -:  192:      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
        -:  193:      {
        -:  194:	template<typename _Rep, typename _Period>
        -:  195:	  static constexpr _ToDur
        -:  196:	  __cast(const duration<_Rep, _Period>& __d)
        -:  197:	  {
        -:  198:	    typedef typename _ToDur::rep			__to_rep;
        -:  199:	    return _ToDur(static_cast<__to_rep>(__d.count()));
        -:  200:	  }
        -:  201:      };
        -:  202:
        -:  203:    template<typename _ToDur, typename _CF, typename _CR>
        -:  204:      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
        -:  205:      {
        -:  206:	template<typename _Rep, typename _Period>
        -:  207:	  static constexpr _ToDur
function _ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000EEEES2_ILl1ELl1000000EElLb1ELb0EE6__castIlS2_ILl1ELl1000000000EEEES4_RKNS1_IT_T0_EE called 123 returned 100% blocks executed 100%
      123:  208:	  __cast(const duration<_Rep, _Period>& __d)
        -:  209:	  {
        -:  210:	    typedef typename _ToDur::rep			__to_rep;
      246:  211:	    return _ToDur(static_cast<__to_rep>(
      123:  212:	      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
      123:  212-block  0
call    0 returned 123
call    1 returned 123
        -:  213:	  }
        -:  214:      };
        -:  215:
        -:  216:    template<typename _ToDur, typename _CF, typename _CR>
        -:  217:      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
        -:  218:      {
        -:  219:	template<typename _Rep, typename _Period>
        -:  220:	  static constexpr _ToDur
function _ZNSt6chrono20__duration_cast_implINS_8durationIlSt5ratioILl1ELl1000000000EEEES2_ILl1000000000ELl1EElLb0ELb1EE6__castIlS2_ILl1ELl1EEEES4_RKNS1_IT_T0_EE called 62 returned 100% blocks executed 100%
       62:  221:	  __cast(const duration<_Rep, _Period>& __d)
        -:  222:	  {
        -:  223:	    typedef typename _ToDur::rep			__to_rep;
      124:  224:	    return _ToDur(static_cast<__to_rep>(
       62:  225:	      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
       62:  225-block  0
call    0 returned 62
call    1 returned 62
        -:  226:	  }
        -:  227:      };
        -:  228:
        -:  229:    template<typename _Tp>
        -:  230:      struct __is_duration
        -:  231:      : std::false_type
        -:  232:      { };
        -:  233:
        -:  234:    template<typename _Rep, typename _Period>
        -:  235:      struct __is_duration<duration<_Rep, _Period>>
        -:  236:      : std::true_type
        -:  237:      { };
        -:  238:
        -:  239:    template<typename _Tp>
        -:  240:      using __enable_if_is_duration
        -:  241:	= typename enable_if<__is_duration<_Tp>::value, _Tp>::type;
        -:  242:
        -:  243:    template<typename _Tp>
        -:  244:      using __disable_if_is_duration
        -:  245:	= typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;
        -:  246:
        -:  247:#if __cplusplus >= 201703L
        -:  248:    template<typename _Tp>
        -:  249:      inline constexpr bool __is_duration_v = false;
        -:  250:    template<typename _Rep, typename _Period>
        -:  251:      inline constexpr bool __is_duration_v<duration<_Rep, _Period>> = true;
        -:  252:    template<typename _Tp>
        -:  253:      inline constexpr bool __is_time_point_v = false;
        -:  254:    template<typename _Clock, typename _Dur>
        -:  255:      inline constexpr bool __is_time_point_v<time_point<_Clock, _Dur>> = true;
        -:  256:#endif
        -:  257:
        -:  258:    /// @endcond
        -:  259:
        -:  260:    /** Convert a `duration` to type `ToDur`.
        -:  261:     *
        -:  262:     * If the duration cannot be represented accurately in the result type,
        -:  263:     * returns the result of integer truncation (i.e., rounded towards zero).
        -:  264:     *
        -:  265:     * @tparam _ToDur The result type must be a `duration`.
        -:  266:     * @param __d A duration.
        -:  267:     * @return The value of `__d` converted to type `_ToDur`.
        -:  268:     * @since C++11
        -:  269:     */
        -:  270:    template<typename _ToDur, typename _Rep, typename _Period>
        -:  271:      _GLIBCXX_NODISCARD
        -:  272:      constexpr __enable_if_is_duration<_ToDur>
      185:  273:      duration_cast(const duration<_Rep, _Period>& __d)
        -:  274:      {
        -:  275:#if __cpp_inline_variables && __cpp_if_constexpr
        -:  276:	if constexpr (is_same_v<_ToDur, duration<_Rep, _Period>>)
        -:  277:	  return __d;
        -:  278:	else
        -:  279:#endif
        -:  280:	{
        -:  281:	  using __to_period = typename _ToDur::period;
        -:  282:	  using __to_rep = typename _ToDur::rep;
        -:  283:	  using __cf = ratio_divide<_Period, __to_period>;
        -:  284:	  using __cr = typename common_type<__to_rep, _Rep, intmax_t>::type;
        -:  285:	  using __dc = __duration_cast_impl<_ToDur, __cf, __cr,
        -:  286:					    __cf::num == 1, __cf::den == 1>;
      185:  287:	  return __dc::__cast(__d);
        -:  288:	}
        -:  289:      }
------------------
_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS2_ILl1ELl1EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE:
function _ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000000000EEEElS2_ILl1ELl1EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE called 62 returned 100% blocks executed 100%
       62:  273:      duration_cast(const duration<_Rep, _Period>& __d)
        -:  274:      {
        -:  275:#if __cpp_inline_variables && __cpp_if_constexpr
        -:  276:	if constexpr (is_same_v<_ToDur, duration<_Rep, _Period>>)
        -:  277:	  return __d;
        -:  278:	else
        -:  279:#endif
        -:  280:	{
        -:  281:	  using __to_period = typename _ToDur::period;
        -:  282:	  using __to_rep = typename _ToDur::rep;
        -:  283:	  using __cf = ratio_divide<_Period, __to_period>;
        -:  284:	  using __cr = typename common_type<__to_rep, _Rep, intmax_t>::type;
        -:  285:	  using __dc = __duration_cast_impl<_ToDur, __cf, __cr,
        -:  286:					    __cf::num == 1, __cf::den == 1>;
       62:  287:	  return __dc::__cast(__d);
       62:  287-block  0
call    0 returned 62
        -:  288:	}
        -:  289:      }
------------------
_ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000EEEElS2_ILl1ELl1000000000EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE:
function _ZNSt6chrono13duration_castINS_8durationIlSt5ratioILl1ELl1000EEEElS2_ILl1ELl1000000000EEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueES8_E4typeERKNS1_IT0_T1_EE called 123 returned 100% blocks executed 100%
      123:  273:      duration_cast(const duration<_Rep, _Period>& __d)
        -:  274:      {
        -:  275:#if __cpp_inline_variables && __cpp_if_constexpr
        -:  276:	if constexpr (is_same_v<_ToDur, duration<_Rep, _Period>>)
        -:  277:	  return __d;
        -:  278:	else
        -:  279:#endif
        -:  280:	{
        -:  281:	  using __to_period = typename _ToDur::period;
        -:  282:	  using __to_rep = typename _ToDur::rep;
        -:  283:	  using __cf = ratio_divide<_Period, __to_period>;
        -:  284:	  using __cr = typename common_type<__to_rep, _Rep, intmax_t>::type;
        -:  285:	  using __dc = __duration_cast_impl<_ToDur, __cf, __cr,
        -:  286:					    __cf::num == 1, __cf::den == 1>;
      123:  287:	  return __dc::__cast(__d);
      123:  287-block  0
call    0 returned 123
        -:  288:	}
        -:  289:      }
------------------
        -:  290:
        -:  291:    /** Trait indicating whether to treat a type as a floating-point type.
        -:  292:     *
        -:  293:     * The chrono library uses this trait to tell whether a `duration` can
        -:  294:     * represent fractional values of the given precision, or only integral
        -:  295:     * values.
        -:  296:     *
        -:  297:     * You should specialize this trait for your own numeric types that are
        -:  298:     * used with `duration` and can represent non-integral values.
        -:  299:     *
        -:  300:     * @since C++11
        -:  301:     */
        -:  302:    template<typename _Rep>
        -:  303:      struct treat_as_floating_point
        -:  304:      : is_floating_point<_Rep>
        -:  305:      { };
        -:  306:
        -:  307:#if __cplusplus > 201402L
        -:  308:    template <typename _Rep>
        -:  309:      inline constexpr bool treat_as_floating_point_v =
        -:  310:	treat_as_floating_point<_Rep>::value;
        -:  311:
        -:  312:    template<>
        -:  313:      inline constexpr bool treat_as_floating_point_v<int> = false;
        -:  314:    template<>
        -:  315:      inline constexpr bool treat_as_floating_point_v<long> = false;
        -:  316:    template<>
        -:  317:      inline constexpr bool treat_as_floating_point_v<long long> = false;
        -:  318:    template<>
        -:  319:      inline constexpr bool treat_as_floating_point_v<float> = true;
        -:  320:    template<>
        -:  321:      inline constexpr bool treat_as_floating_point_v<double> = true;
        -:  322:    template<>
        -:  323:      inline constexpr bool treat_as_floating_point_v<long double> = true;
        -:  324:#endif // C++17
        -:  325:
        -:  326:#if __cplusplus > 201703L
        -:  327:#if __cpp_lib_concepts
        -:  328:    template<typename _Tp>
        -:  329:      inline constexpr bool is_clock_v = false;
        -:  330:
        -:  331:    template<typename _Tp>
        -:  332:      requires requires {
        -:  333:	typename _Tp::rep;
        -:  334:	typename _Tp::period;
        -:  335:	typename _Tp::duration;
        -:  336:	typename _Tp::time_point::clock;
        -:  337:	typename _Tp::time_point::duration;
        -:  338:	{ &_Tp::is_steady } -> same_as<const bool*>;
        -:  339:	{ _Tp::now() } -> same_as<typename _Tp::time_point>;
        -:  340:	requires same_as<typename _Tp::duration,
        -:  341:			 duration<typename _Tp::rep, typename _Tp::period>>;
        -:  342:	requires same_as<typename _Tp::time_point::duration,
        -:  343:			 typename _Tp::duration>;
        -:  344:      }
        -:  345:    inline constexpr bool is_clock_v<_Tp> = true;
        -:  346:#else
        -:  347:    template<typename _Tp, typename = void>
        -:  348:      inline constexpr bool is_clock_v = false;
        -:  349:
        -:  350:    template<typename _Tp>
        -:  351:      inline constexpr bool
        -:  352:      is_clock_v<_Tp, void_t<typename _Tp::rep, typename _Tp::period,
        -:  353:			     typename _Tp::duration,
        -:  354:			     typename _Tp::time_point::duration,
        -:  355:			     decltype(_Tp::is_steady),
        -:  356:			     decltype(_Tp::now())>>
        -:  357:	= __and_v<is_same<typename _Tp::duration,
        -:  358:			  duration<typename _Tp::rep, typename _Tp::period>>,
        -:  359:		  is_same<typename _Tp::time_point::duration,
        -:  360:			  typename _Tp::duration>,
        -:  361:		  is_same<decltype(&_Tp::is_steady), const bool*>,
        -:  362:		  is_same<decltype(_Tp::now()), typename _Tp::time_point>>;
        -:  363:#endif
        -:  364:
        -:  365:    template<typename _Tp>
        -:  366:      struct is_clock
        -:  367:      : bool_constant<is_clock_v<_Tp>>
        -:  368:      { };
        -:  369:#endif // C++20
        -:  370:
        -:  371:#if __cplusplus >= 201703L
        -:  372:# define __cpp_lib_chrono 201611L
        -:  373:
        -:  374:    /** Convert a `duration` to type `ToDur` and round down.
        -:  375:     *
        -:  376:     * If the duration cannot be represented exactly in the result type,
        -:  377:     * returns the closest value that is less than the argument.
        -:  378:     *
        -:  379:     * @tparam _ToDur The result type must be a `duration`.
        -:  380:     * @param __d A duration.
        -:  381:     * @return The value of `__d` converted to type `_ToDur`.
        -:  382:     * @since C++17
        -:  383:     */
        -:  384:    template<typename _ToDur, typename _Rep, typename _Period>
        -:  385:      [[nodiscard]] constexpr __enable_if_is_duration<_ToDur>
        -:  386:      floor(const duration<_Rep, _Period>& __d)
        -:  387:      {
        -:  388:	auto __to = chrono::duration_cast<_ToDur>(__d);
        -:  389:	if (__to > __d)
        -:  390:	  return __to - _ToDur{1};
        -:  391:	return __to;
        -:  392:      }
        -:  393:
        -:  394:    /** Convert a `duration` to type `ToDur` and round up.
        -:  395:     *
        -:  396:     * If the duration cannot be represented exactly in the result type,
        -:  397:     * returns the closest value that is greater than the argument.
        -:  398:     *
        -:  399:     * @tparam _ToDur The result type must be a `duration`.
        -:  400:     * @param __d A duration.
        -:  401:     * @return The value of `__d` converted to type `_ToDur`.
        -:  402:     * @since C++17
        -:  403:     */
        -:  404:    template<typename _ToDur, typename _Rep, typename _Period>
        -:  405:      [[nodiscard]] constexpr __enable_if_is_duration<_ToDur>
        -:  406:      ceil(const duration<_Rep, _Period>& __d)
        -:  407:      {
        -:  408:	auto __to = chrono::duration_cast<_ToDur>(__d);
        -:  409:	if (__to < __d)
        -:  410:	  return __to + _ToDur{1};
        -:  411:	return __to;
        -:  412:      }
        -:  413:
        -:  414:    /** Convert a `duration` to type `ToDur` and round to the closest value.
        -:  415:     *
        -:  416:     * If the duration cannot be represented exactly in the result type,
        -:  417:     * returns the closest value, rounding ties to even.
        -:  418:     *
        -:  419:     * @tparam _ToDur The result type must be a `duration` with a
        -:  420:     *                non-floating-point `rep` type.
        -:  421:     * @param __d A duration.
        -:  422:     * @return The value of `__d` converted to type `_ToDur`.
        -:  423:     * @since C++17
        -:  424:     */
        -:  425:    template <typename _ToDur, typename _Rep, typename _Period>
        -:  426:      [[nodiscard]] constexpr
        -:  427:      enable_if_t<
        -:  428:	__and_<__is_duration<_ToDur>,
        -:  429:	       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,
        -:  430:	_ToDur>
        -:  431:      round(const duration<_Rep, _Period>& __d)
        -:  432:      {
        -:  433:	_ToDur __t0 = chrono::floor<_ToDur>(__d);
        -:  434:	_ToDur __t1 = __t0 + _ToDur{1};
        -:  435:	auto __diff0 = __d - __t0;
        -:  436:	auto __diff1 = __t1 - __d;
        -:  437:	if (__diff0 == __diff1)
        -:  438:	  {
        -:  439:	    if (__t0.count() & 1)
        -:  440:	      return __t1;
        -:  441:	    return __t0;
        -:  442:	  }
        -:  443:	else if (__diff0 < __diff1)
        -:  444:	  return __t0;
        -:  445:	return __t1;
        -:  446:      }
        -:  447:
        -:  448:    /** The absolute (non-negative) value of a duration.
        -:  449:     *
        -:  450:     * @param __d A duration with a signed `rep` type.
        -:  451:     * @return A duration of the same type as the argument, with value |d|.
        -:  452:     * @since C++17
        -:  453:     */
        -:  454:    template<typename _Rep, typename _Period>
        -:  455:      [[nodiscard]] constexpr
        -:  456:      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>
        -:  457:      abs(duration<_Rep, _Period> __d)
        -:  458:      {
        -:  459:	if (__d >= __d.zero())
        -:  460:	  return __d;
        -:  461:	return -__d;
        -:  462:      }
        -:  463:
        -:  464:    // Make chrono::ceil<D> also usable as chrono::__detail::ceil<D>.
        -:  465:    namespace __detail { using chrono::ceil; }
        -:  466:
        -:  467:#else // ! C++17
        -:  468:
        -:  469:    // We want to use ceil even when compiling for earlier standards versions.
        -:  470:    // C++11 only allows a single statement in a constexpr function, so we
        -:  471:    // need to move the comparison into a separate function, __ceil_impl.
        -:  472:    namespace __detail
        -:  473:    {
        -:  474:      template<typename _Tp, typename _Up>
        -:  475:	constexpr _Tp
        -:  476:	__ceil_impl(const _Tp& __t, const _Up& __u)
        -:  477:	{
        -:  478:	  return (__t < __u) ? (__t + _Tp{1}) : __t;
        -:  479:	}
        -:  480:
        -:  481:      // C++11-friendly version of std::chrono::ceil<D> for internal use.
        -:  482:      template<typename _ToDur, typename _Rep, typename _Period>
        -:  483:	constexpr _ToDur
        -:  484:	ceil(const duration<_Rep, _Period>& __d)
        -:  485:	{
        -:  486:	  return __detail::__ceil_impl(chrono::duration_cast<_ToDur>(__d), __d);
        -:  487:	}
        -:  488:    }
        -:  489:#endif // C++17
        -:  490:
        -:  491:    /// duration_values
        -:  492:    template<typename _Rep>
        -:  493:      struct duration_values
        -:  494:      {
        -:  495:	static constexpr _Rep
        -:  496:	zero() noexcept
        -:  497:	{ return _Rep(0); }
        -:  498:
        -:  499:	static constexpr _Rep
        -:  500:	max() noexcept
        -:  501:	{ return numeric_limits<_Rep>::max(); }
        -:  502:
        -:  503:	static constexpr _Rep
        -:  504:	min() noexcept
        -:  505:	{ return numeric_limits<_Rep>::lowest(); }
        -:  506:      };
        -:  507:
        -:  508:    template<typename _Rep, typename _Period>
        -:  509:      class duration
        -:  510:      {
        -:  511:	static_assert(!__is_duration<_Rep>::value,
        -:  512:		      "rep cannot be a std::chrono::duration");
        -:  513:	static_assert(__is_ratio<_Period>::value,
        -:  514:		      "period must be a specialization of std::ratio");
        -:  515:	static_assert(_Period::num > 0, "period must be positive");
        -:  516:
        -:  517:	template<typename _Rep2>
        -:  518:	  using __is_float = treat_as_floating_point<_Rep2>;
        -:  519:
        -:  520:	static constexpr intmax_t
        -:  521:	_S_gcd(intmax_t __m, intmax_t __n) noexcept
        -:  522:	{
        -:  523:	  // Duration only allows positive periods so we don't need to
        -:  524:	  // handle negative values here (unlike __static_gcd and std::gcd).
        -:  525:#if __cplusplus >= 201402L
        -:  526:	  do
        -:  527:	    {
        -:  528:	      intmax_t __rem = __m % __n;
        -:  529:	      __m = __n;
        -:  530:	      __n = __rem;
        -:  531:	    }
        -:  532:	  while (__n != 0);
        -:  533:	  return __m;
        -:  534:#else
        -:  535:	  // C++11 doesn't allow loops in constexpr functions, but this
        -:  536:	  // recursive version can be more expensive to evaluate.
        -:  537:	  return (__n == 0) ? __m : _S_gcd(__n, __m % __n);
        -:  538:#endif
        -:  539:	}
        -:  540:
        -:  541:	// _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  542:	// 2094. overflow shouldn't participate in overload resolution
        -:  543:	// 3090. What is [2094] intended to mean?
        -:  544:	// This only produces a valid type if no overflow occurs.
        -:  545:	template<typename _R1, typename _R2,
        -:  546:		 intmax_t __gcd1 = _S_gcd(_R1::num, _R2::num),
        -:  547:		 intmax_t __gcd2 = _S_gcd(_R1::den, _R2::den)>
        -:  548:	  using __divide = ratio<(_R1::num / __gcd1) * (_R2::den / __gcd2),
        -:  549:				 (_R1::den / __gcd2) * (_R2::num / __gcd1)>;
        -:  550:
        -:  551:	// _Period2 is an exact multiple of _Period
        -:  552:	template<typename _Period2>
        -:  553:	  using __is_harmonic
        -:  554:	    = __bool_constant<__divide<_Period2, _Period>::den == 1>;
        -:  555:
        -:  556:      public:
        -:  557:
        -:  558:	using rep = _Rep;
        -:  559:	using period = typename _Period::type;
        -:  560:
        -:  561:	// 20.11.5.1 construction / copy / destroy
        -:  562:	constexpr duration() = default;
        -:  563:
        -:  564:	duration(const duration&) = default;
        -:  565:
        -:  566:	// _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  567:	// 3050. Conversion specification problem in chrono::duration
        -:  568:	template<typename _Rep2, typename = _Require<
        -:  569:		 is_convertible<const _Rep2&, rep>,
        -:  570:		 __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>
      370:  571:	  constexpr explicit duration(const _Rep2& __rep)
      370:  572:	  : __r(static_cast<rep>(__rep)) { }
------------------
_ZNSt6chrono8durationIlSt5ratioILl1ELl1000EEEC2IlvEERKT_:
function _ZNSt6chrono8durationIlSt5ratioILl1ELl1000EEEC2IlvEERKT_ called 123 returned 100% blocks executed 100%
      123:  571:	  constexpr explicit duration(const _Rep2& __rep)
      123:  572:	  : __r(static_cast<rep>(__rep)) { }
------------------
_ZNSt6chrono8durationIlSt5ratioILl1ELl1EEEC1IlvEERKT_:
function _ZNSt6chrono8durationIlSt5ratioILl1ELl1EEEC1IlvEERKT_ called 62 returned 100% blocks executed 100%
       62:  571:	  constexpr explicit duration(const _Rep2& __rep)
       62:  572:	  : __r(static_cast<rep>(__rep)) { }
------------------
_ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC1IlvEERKT_:
function _ZNSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEC1IlvEERKT_ called 185 returned 100% blocks executed 100%
      185:  571:	  constexpr explicit duration(const _Rep2& __rep)
      185:  572:	  : __r(static_cast<rep>(__rep)) { }
------------------
        -:  573:
        -:  574:	template<typename _Rep2, typename _Period2, typename = _Require<
        -:  575:		 is_convertible<const _Rep2&, rep>,
        -:  576:		 __or_<__is_float<rep>,
        -:  577:		       __and_<__is_harmonic<_Period2>,
        -:  578:			      __not_<__is_float<_Rep2>>>>>>
        -:  579:	  constexpr duration(const duration<_Rep2, _Period2>& __d)
        -:  580:	  : __r(duration_cast<duration>(__d).count()) { }
        -:  581:
        -:  582:	~duration() = default;
        -:  583:	duration& operator=(const duration&) = default;
        -:  584:
        -:  585:	// 20.11.5.2 observer
        -:  586:	constexpr rep
      554:  587:	count() const
      554:  588:	{ return __r; }
------------------
_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000EEE5countEv:
function _ZNKSt6chrono8durationIlSt5ratioILl1ELl1000EEE5countEv called 123 returned 100% blocks executed 100%
      123:  587:	count() const
      123:  588:	{ return __r; }
      123:  588-block  0
------------------
_ZNKSt6chrono8durationIlSt5ratioILl1ELl1EEE5countEv:
function _ZNKSt6chrono8durationIlSt5ratioILl1ELl1EEE5countEv called 62 returned 100% blocks executed 100%
       62:  587:	count() const
       62:  588:	{ return __r; }
       62:  588-block  0
------------------
_ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv:
function _ZNKSt6chrono8durationIlSt5ratioILl1ELl1000000000EEE5countEv called 369 returned 100% blocks executed 100%
      369:  587:	count() const
      369:  588:	{ return __r; }
      369:  588-block  0
------------------
        -:  589:
        -:  590:	// 20.11.5.3 arithmetic
        -:  591:
        -:  592:	constexpr duration<typename common_type<rep>::type, period>
        -:  593:	operator+() const
        -:  594:	{ return duration<typename common_type<rep>::type, period>(__r); }
        -:  595:
        -:  596:	constexpr duration<typename common_type<rep>::type, period>
        -:  597:	operator-() const
        -:  598:	{ return duration<typename common_type<rep>::type, period>(-__r); }
        -:  599:
        -:  600:	_GLIBCXX17_CONSTEXPR duration&
        -:  601:	operator++()
        -:  602:	{
        -:  603:	  ++__r;
        -:  604:	  return *this;
        -:  605:	}
        -:  606:
        -:  607:	_GLIBCXX17_CONSTEXPR duration
        -:  608:	operator++(int)
        -:  609:	{ return duration(__r++); }
        -:  610:
        -:  611:	_GLIBCXX17_CONSTEXPR duration&
        -:  612:	operator--()
        -:  613:	{
        -:  614:	  --__r;
        -:  615:	  return *this;
        -:  616:	}
        -:  617:
        -:  618:	_GLIBCXX17_CONSTEXPR duration
        -:  619:	operator--(int)
        -:  620:	{ return duration(__r--); }
        -:  621:
        -:  622:	_GLIBCXX17_CONSTEXPR duration&
        -:  623:	operator+=(const duration& __d)
        -:  624:	{
        -:  625:	  __r += __d.count();
        -:  626:	  return *this;
        -:  627:	}
        -:  628:
        -:  629:	_GLIBCXX17_CONSTEXPR duration&
        -:  630:	operator-=(const duration& __d)
        -:  631:	{
        -:  632:	  __r -= __d.count();
        -:  633:	  return *this;
        -:  634:	}
        -:  635:
        -:  636:	_GLIBCXX17_CONSTEXPR duration&
        -:  637:	operator*=(const rep& __rhs)
        -:  638:	{
        -:  639:	  __r *= __rhs;
        -:  640:	  return *this;
        -:  641:	}
        -:  642:
        -:  643:	_GLIBCXX17_CONSTEXPR duration&
        -:  644:	operator/=(const rep& __rhs)
        -:  645:	{
        -:  646:	  __r /= __rhs;
        -:  647:	  return *this;
        -:  648:	}
        -:  649:
        -:  650:	// DR 934.
        -:  651:	template<typename _Rep2 = rep>
        -:  652:	  _GLIBCXX17_CONSTEXPR
        -:  653:	  __enable_if_t<!treat_as_floating_point<_Rep2>::value, duration&>
        -:  654:	  operator%=(const rep& __rhs)
        -:  655:	  {
        -:  656:	    __r %= __rhs;
        -:  657:	    return *this;
        -:  658:	  }
        -:  659:
        -:  660:	template<typename _Rep2 = rep>
        -:  661:	  _GLIBCXX17_CONSTEXPR
        -:  662:	  __enable_if_t<!treat_as_floating_point<_Rep2>::value, duration&>
        -:  663:	  operator%=(const duration& __d)
        -:  664:	  {
        -:  665:	    __r %= __d.count();
        -:  666:	    return *this;
        -:  667:	  }
        -:  668:
        -:  669:	// 20.11.5.4 special values
        -:  670:	static constexpr duration
        -:  671:	zero() noexcept
        -:  672:	{ return duration(duration_values<rep>::zero()); }
        -:  673:
        -:  674:	static constexpr duration
        -:  675:	min() noexcept
        -:  676:	{ return duration(duration_values<rep>::min()); }
        -:  677:
        -:  678:	static constexpr duration
        -:  679:	max() noexcept
        -:  680:	{ return duration(duration_values<rep>::max()); }
        -:  681:
        -:  682:      private:
        -:  683:	rep __r;
        -:  684:      };
        -:  685:
        -:  686:    /// @{
        -:  687:    /// @relates std::chrono::duration
        -:  688:
        -:  689:    /// The sum of two durations.
        -:  690:    template<typename _Rep1, typename _Period1,
        -:  691:	     typename _Rep2, typename _Period2>
        -:  692:      constexpr typename common_type<duration<_Rep1, _Period1>,
        -:  693:				     duration<_Rep2, _Period2>>::type
        -:  694:      operator+(const duration<_Rep1, _Period1>& __lhs,
        -:  695:		const duration<_Rep2, _Period2>& __rhs)
        -:  696:      {
        -:  697:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  698:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  699:	typedef typename common_type<__dur1,__dur2>::type	__cd;
        -:  700:	return __cd(__cd(__lhs).count() + __cd(__rhs).count());
        -:  701:      }
        -:  702:
        -:  703:    /// The difference between two durations.
        -:  704:    template<typename _Rep1, typename _Period1,
        -:  705:	     typename _Rep2, typename _Period2>
        -:  706:      constexpr typename common_type<duration<_Rep1, _Period1>,
        -:  707:				     duration<_Rep2, _Period2>>::type
function _ZNSt6chronomiIlSt5ratioILl1ELl1000000000EElS2_EENSt11common_typeIJNS_8durationIT_T0_EENS4_IT1_T2_EEEE4typeERKS7_RKSA_ called 123 returned 100% blocks executed 100%
      123:  708:      operator-(const duration<_Rep1, _Period1>& __lhs,
        -:  709:		const duration<_Rep2, _Period2>& __rhs)
        -:  710:      {
        -:  711:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  712:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  713:	typedef typename common_type<__dur1,__dur2>::type	__cd;
      123:  714:	return __cd(__cd(__lhs).count() - __cd(__rhs).count());
      123:  714-block  0
call    0 returned 123
call    1 returned 123
call    2 returned 123
      123:  714-block  1
        -:  715:      }
        -:  716:
        -:  717:    /// @}
        -:  718:
        -:  719:    /// @cond undocumented
        -:  720:
        -:  721:    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2
        -:  722:    // is implicitly convertible to it.
        -:  723:    // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  724:    // 3050. Conversion specification problem in chrono::duration constructor
        -:  725:    template<typename _Rep1, typename _Rep2,
        -:  726:	     typename _CRep = typename common_type<_Rep1, _Rep2>::type>
        -:  727:      using __common_rep_t = typename
        -:  728:	enable_if<is_convertible<const _Rep2&, _CRep>::value, _CRep>::type;
        -:  729:
        -:  730:    /// @endcond
        -:  731:
        -:  732:    /** @{
        -:  733:     * Arithmetic operators for chrono::duration
        -:  734:     * @relates std::chrono::duration
        -:  735:     */
        -:  736:
        -:  737:    template<typename _Rep1, typename _Period, typename _Rep2>
        -:  738:      constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>
        -:  739:      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
        -:  740:      {
        -:  741:	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
        -:  742:	  __cd;
        -:  743:	return __cd(__cd(__d).count() * __s);
        -:  744:      }
        -:  745:
        -:  746:    template<typename _Rep1, typename _Rep2, typename _Period>
        -:  747:      constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>
        -:  748:      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
        -:  749:      { return __d * __s; }
        -:  750:
        -:  751:    template<typename _Rep1, typename _Period, typename _Rep2>
        -:  752:      constexpr
        -:  753:      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
        -:  754:      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
        -:  755:      {
        -:  756:	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
        -:  757:	  __cd;
        -:  758:	return __cd(__cd(__d).count() / __s);
        -:  759:      }
        -:  760:
        -:  761:    template<typename _Rep1, typename _Period1,
        -:  762:	     typename _Rep2, typename _Period2>
        -:  763:      constexpr typename common_type<_Rep1, _Rep2>::type
        -:  764:      operator/(const duration<_Rep1, _Period1>& __lhs,
        -:  765:		const duration<_Rep2, _Period2>& __rhs)
        -:  766:      {
        -:  767:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  768:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  769:	typedef typename common_type<__dur1,__dur2>::type	__cd;
        -:  770:	return __cd(__lhs).count() / __cd(__rhs).count();
        -:  771:      }
        -:  772:
        -:  773:    // DR 934.
        -:  774:    template<typename _Rep1, typename _Period, typename _Rep2>
        -:  775:      constexpr
        -:  776:      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>
        -:  777:      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
        -:  778:      {
        -:  779:	typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
        -:  780:	  __cd;
        -:  781:	return __cd(__cd(__d).count() % __s);
        -:  782:      }
        -:  783:
        -:  784:    template<typename _Rep1, typename _Period1,
        -:  785:	     typename _Rep2, typename _Period2>
        -:  786:      constexpr typename common_type<duration<_Rep1, _Period1>,
        -:  787:				     duration<_Rep2, _Period2>>::type
        -:  788:      operator%(const duration<_Rep1, _Period1>& __lhs,
        -:  789:		const duration<_Rep2, _Period2>& __rhs)
        -:  790:      {
        -:  791:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  792:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  793:	typedef typename common_type<__dur1,__dur2>::type	__cd;
        -:  794:	return __cd(__cd(__lhs).count() % __cd(__rhs).count());
        -:  795:      }
        -:  796:    /// @}
        -:  797:
        -:  798:    // comparisons
        -:  799:
        -:  800:    /** @{
        -:  801:     * Comparisons for chrono::duration
        -:  802:     * @relates std::chrono::duration
        -:  803:     */
        -:  804:
        -:  805:    template<typename _Rep1, typename _Period1,
        -:  806:	     typename _Rep2, typename _Period2>
        -:  807:      constexpr bool
        -:  808:      operator==(const duration<_Rep1, _Period1>& __lhs,
        -:  809:		 const duration<_Rep2, _Period2>& __rhs)
        -:  810:      {
        -:  811:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  812:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  813:	typedef typename common_type<__dur1,__dur2>::type	__ct;
        -:  814:	return __ct(__lhs).count() == __ct(__rhs).count();
        -:  815:      }
        -:  816:
        -:  817:    template<typename _Rep1, typename _Period1,
        -:  818:	     typename _Rep2, typename _Period2>
        -:  819:      constexpr bool
        -:  820:      operator<(const duration<_Rep1, _Period1>& __lhs,
        -:  821:		const duration<_Rep2, _Period2>& __rhs)
        -:  822:      {
        -:  823:	typedef duration<_Rep1, _Period1>			__dur1;
        -:  824:	typedef duration<_Rep2, _Period2>			__dur2;
        -:  825:	typedef typename common_type<__dur1,__dur2>::type	__ct;
        -:  826:	return __ct(__lhs).count() < __ct(__rhs).count();
        -:  827:      }
        -:  828:
        -:  829:#if __cpp_lib_three_way_comparison
        -:  830:    template<typename _Rep1, typename _Period1,
        -:  831:	     typename _Rep2, typename _Period2>
        -:  832:      requires three_way_comparable<common_type_t<_Rep1, _Rep2>>
        -:  833:      constexpr auto
        -:  834:      operator<=>(const duration<_Rep1, _Period1>& __lhs,
        -:  835:		  const duration<_Rep2, _Period2>& __rhs)
        -:  836:      {
        -:  837:	using __ct = common_type_t<duration<_Rep1, _Period1>,
        -:  838:				   duration<_Rep2, _Period2>>;
        -:  839:	return __ct(__lhs).count() <=> __ct(__rhs).count();
        -:  840:      }
        -:  841:#else
        -:  842:    template<typename _Rep1, typename _Period1,
        -:  843:	     typename _Rep2, typename _Period2>
        -:  844:      constexpr bool
        -:  845:      operator!=(const duration<_Rep1, _Period1>& __lhs,
        -:  846:		 const duration<_Rep2, _Period2>& __rhs)
        -:  847:      { return !(__lhs == __rhs); }
        -:  848:#endif
        -:  849:
        -:  850:    template<typename _Rep1, typename _Period1,
        -:  851:	     typename _Rep2, typename _Period2>
        -:  852:      constexpr bool
        -:  853:      operator<=(const duration<_Rep1, _Period1>& __lhs,
        -:  854:		 const duration<_Rep2, _Period2>& __rhs)
        -:  855:      { return !(__rhs < __lhs); }
        -:  856:
        -:  857:    template<typename _Rep1, typename _Period1,
        -:  858:	     typename _Rep2, typename _Period2>
        -:  859:      constexpr bool
        -:  860:      operator>(const duration<_Rep1, _Period1>& __lhs,
        -:  861:		const duration<_Rep2, _Period2>& __rhs)
        -:  862:      { return __rhs < __lhs; }
        -:  863:
        -:  864:    template<typename _Rep1, typename _Period1,
        -:  865:	     typename _Rep2, typename _Period2>
        -:  866:      constexpr bool
        -:  867:      operator>=(const duration<_Rep1, _Period1>& __lhs,
        -:  868:		 const duration<_Rep2, _Period2>& __rhs)
        -:  869:      { return !(__lhs < __rhs); }
        -:  870:
        -:  871:    /// @}
        -:  872:
        -:  873:    /// @cond undocumented
        -:  874:#ifdef _GLIBCXX_USE_C99_STDINT_TR1
        -:  875:# define _GLIBCXX_CHRONO_INT64_T int64_t
        -:  876:#elif defined __INT64_TYPE__
        -:  877:# define _GLIBCXX_CHRONO_INT64_T __INT64_TYPE__
        -:  878:#else
        -:  879:    static_assert(std::numeric_limits<unsigned long long>::digits >= 64,
        -:  880:	"Representation type for nanoseconds must have at least 64 bits");
        -:  881:# define _GLIBCXX_CHRONO_INT64_T long long
        -:  882:#endif
        -:  883:    /// @endcond
        -:  884:
        -:  885:    /// nanoseconds
        -:  886:    using nanoseconds	= duration<_GLIBCXX_CHRONO_INT64_T, nano>;
        -:  887:
        -:  888:    /// microseconds
        -:  889:    using microseconds	= duration<_GLIBCXX_CHRONO_INT64_T, micro>;
        -:  890:
        -:  891:    /// milliseconds
        -:  892:    using milliseconds	= duration<_GLIBCXX_CHRONO_INT64_T, milli>;
        -:  893:
        -:  894:    /// seconds
        -:  895:    using seconds	= duration<_GLIBCXX_CHRONO_INT64_T>;
        -:  896:
        -:  897:    /// minutes
        -:  898:    using minutes	= duration<_GLIBCXX_CHRONO_INT64_T, ratio< 60>>;
        -:  899:
        -:  900:    /// hours
        -:  901:    using hours		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;
        -:  902:
        -:  903:#if __cplusplus > 201703L
        -:  904:    /// days
        -:  905:    using days		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;
        -:  906:
        -:  907:    /// weeks
        -:  908:    using weeks		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;
        -:  909:
        -:  910:    /// years
        -:  911:    using years		= duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;
        -:  912:
        -:  913:    /// months
        -:  914:    using months	= duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;
        -:  915:#endif // C++20
        -:  916:
        -:  917:#undef _GLIBCXX_CHRONO_INT64_T
        -:  918:
        -:  919:    template<typename _Clock, typename _Dur>
        -:  920:      class time_point
        -:  921:      {
        -:  922:	static_assert(__is_duration<_Dur>::value,
        -:  923:	    "duration must be a specialization of std::chrono::duration");
        -:  924:
        -:  925:      public:
        -:  926:	typedef _Clock						clock;
        -:  927:	typedef _Dur						duration;
        -:  928:	typedef typename duration::rep				rep;
        -:  929:	typedef typename duration::period			period;
        -:  930:
        -:  931:	constexpr time_point() : __d(duration::zero())
        -:  932:	{ }
        -:  933:
      124:  934:	constexpr explicit time_point(const duration& __dur)
      124:  935:	: __d(__dur)
      124:  936:	{ }
------------------
_ZNSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEEC2ERKS6_:
function _ZNSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEEC2ERKS6_ called 62 returned 100% blocks executed 100%
       62:  934:	constexpr explicit time_point(const duration& __dur)
       62:  935:	: __d(__dur)
       62:  936:	{ }
------------------
_ZNSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1EEEEEC1ERKS6_:
function _ZNSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1EEEEEC1ERKS6_ called 62 returned 100% blocks executed 100%
       62:  934:	constexpr explicit time_point(const duration& __dur)
       62:  935:	: __d(__dur)
       62:  936:	{ }
------------------
        -:  937:
        -:  938:	// conversions
        -:  939:	template<typename _Dur2,
        -:  940:		 typename = _Require<is_convertible<_Dur2, _Dur>>>
        -:  941:	  constexpr time_point(const time_point<clock, _Dur2>& __t)
        -:  942:	  : __d(__t.time_since_epoch())
        -:  943:	  { }
        -:  944:
        -:  945:	// observer
        -:  946:	constexpr duration
      308:  947:	time_since_epoch() const
      308:  948:	{ return __d; }
------------------
_ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv:
function _ZNKSt6chrono10time_pointINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv called 122 returned 100% blocks executed 100%
      122:  947:	time_since_epoch() const
      122:  948:	{ return __d; }
      122:  948-block  0
------------------
_ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv:
function _ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEEE16time_since_epochEv called 124 returned 100% blocks executed 100%
      124:  947:	time_since_epoch() const
      124:  948:	{ return __d; }
      124:  948-block  0
------------------
_ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1EEEEE16time_since_epochEv:
function _ZNKSt6chrono10time_pointINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1EEEEE16time_since_epochEv called 62 returned 100% blocks executed 100%
       62:  947:	time_since_epoch() const
       62:  948:	{ return __d; }
       62:  948-block  0
------------------
        -:  949:
        -:  950:#if __cplusplus > 201703L
        -:  951:	constexpr time_point&
        -:  952:	operator++()
        -:  953:	{
        -:  954:	  ++__d;
        -:  955:	  return *this;
        -:  956:	}
        -:  957:
        -:  958:	constexpr time_point
        -:  959:	operator++(int)
        -:  960:	{ return time_point{__d++}; }
        -:  961:
        -:  962:	constexpr time_point&
        -:  963:	operator--()
        -:  964:	{
        -:  965:	  --__d;
        -:  966:	  return *this;
        -:  967:	}
        -:  968:
        -:  969:	constexpr time_point
        -:  970:	operator--(int)
        -:  971:	{ return time_point{__d--}; }
        -:  972:#endif
        -:  973:
        -:  974:	// arithmetic
        -:  975:	_GLIBCXX17_CONSTEXPR time_point&
        -:  976:	operator+=(const duration& __dur)
        -:  977:	{
        -:  978:	  __d += __dur;
        -:  979:	  return *this;
        -:  980:	}
        -:  981:
        -:  982:	_GLIBCXX17_CONSTEXPR time_point&
        -:  983:	operator-=(const duration& __dur)
        -:  984:	{
        -:  985:	  __d -= __dur;
        -:  986:	  return *this;
        -:  987:	}
        -:  988:
        -:  989:	// special values
        -:  990:	static constexpr time_point
        -:  991:	min() noexcept
        -:  992:	{ return time_point(duration::min()); }
        -:  993:
        -:  994:	static constexpr time_point
        -:  995:	max() noexcept
        -:  996:	{ return time_point(duration::max()); }
        -:  997:
        -:  998:      private:
        -:  999:	duration __d;
        -: 1000:      };
        -: 1001:
        -: 1002:    /** Convert a `time_point` to use `duration` type `ToDur`.
        -: 1003:     *
        -: 1004:     * The result is the same time point as measured by the same clock, but
        -: 1005:     * using the specified `duration` to represent the time.
        -: 1006:     * If the time point cannot be represented accurately in the result type,
        -: 1007:     * returns the result of integer truncation (i.e., rounded towards zero).
        -: 1008:     *
        -: 1009:     * @tparam _ToDur The `duration` type to use for the result.
        -: 1010:     * @param __t A time point.
        -: 1011:     * @return The value of `__t` converted to use type `_ToDur`.
        -: 1012:     * @since C++11
        -: 1013:     */
        -: 1014:    template<typename _ToDur, typename _Clock, typename _Dur>
        -: 1015:      _GLIBCXX_NODISCARD constexpr
        -: 1016:      __enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>
function _ZNSt6chrono15time_point_castINS_8durationIlSt5ratioILl1ELl1000000000EEEENS_3_V212system_clockENS1_IlS2_ILl1ELl1EEEEEENSt9enable_ifIXsrNS_13__is_durationIT_EE5valueENS_10time_pointIT0_SB_EEE4typeERKNSD_ISE_T1_EE called 62 returned 100% blocks executed 78%
       62: 1017:      time_point_cast(const time_point<_Clock, _Dur>& __t)
        -: 1018:      {
        -: 1019:	typedef time_point<_Clock, _ToDur>			__time_point;
       62: 1020:	return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
       62: 1020-block  0
call    0 returned 62
call    1 returned 62
branch  2 taken 62 (fallthrough)
branch  3 taken 0 (throw)
       62: 1020-block  1
call    4 returned 62
       62: 1020-block  2
       62: 1020-block  3
    $$$$$: 1020-block  4
    $$$$$: 1020-block  5
        -: 1021:      }
        -: 1022:
        -: 1023:#if __cplusplus > 201402L
        -: 1024:    /** Convert a `time_point` to type `ToDur` and round down.
        -: 1025:     *
        -: 1026:     * The result is the same time point as measured by the same clock, but
        -: 1027:     * using the specified `duration` to represent the time.
        -: 1028:     * If the time point cannot be represented exactly in the result type,
        -: 1029:     * returns the closest value that is less than the argument.
        -: 1030:     *
        -: 1031:     * @tparam _ToDur The `duration` type to use for the result.
        -: 1032:     * @param __t A time point.
        -: 1033:     * @return The value of `__d` converted to type `_ToDur`.
        -: 1034:     * @since C++17
        -: 1035:     */
        -: 1036:    template<typename _ToDur, typename _Clock, typename _Dur>
        -: 1037:      [[nodiscard]] constexpr
        -: 1038:      enable_if_t<__is_duration_v<_ToDur>, time_point<_Clock, _ToDur>>
        -: 1039:      floor(const time_point<_Clock, _Dur>& __tp)
        -: 1040:      {
        -: 1041:	return time_point<_Clock, _ToDur>{
        -: 1042:	    chrono::floor<_ToDur>(__tp.time_since_epoch())};
        -: 1043:      }
        -: 1044:
        -: 1045:    /** Convert a `time_point` to type `ToDur` and round up.
        -: 1046:     *
        -: 1047:     * The result is the same time point as measured by the same clock, but
        -: 1048:     * using the specified `duration` to represent the time.
        -: 1049:     * If the time point cannot be represented exactly in the result type,
        -: 1050:     * returns the closest value that is greater than the argument.
        -: 1051:     *
        -: 1052:     * @tparam _ToDur The `duration` type to use for the result.
        -: 1053:     * @param __t A time point.
        -: 1054:     * @return The value of `__d` converted to type `_ToDur`.
        -: 1055:     * @since C++17
        -: 1056:     */
        -: 1057:    template<typename _ToDur, typename _Clock, typename _Dur>
        -: 1058:      [[nodiscard]] constexpr
        -: 1059:      enable_if_t<__is_duration_v<_ToDur>, time_point<_Clock, _ToDur>>
        -: 1060:      ceil(const time_point<_Clock, _Dur>& __tp)
        -: 1061:      {
        -: 1062:	return time_point<_Clock, _ToDur>{
        -: 1063:	    chrono::ceil<_ToDur>(__tp.time_since_epoch())};
        -: 1064:      }
        -: 1065:
        -: 1066:    /** Convert a `time_point` to type `ToDur` and round to the closest value.
        -: 1067:     *
        -: 1068:     * The result is the same time point as measured by the same clock, but
        -: 1069:     * using the specified `duration` to represent the time.
        -: 1070:     * If the time point cannot be represented exactly in the result type,
        -: 1071:     * returns the closest value, rounding ties to even.
        -: 1072:     *
        -: 1073:     * @tparam _ToDur The `duration` type to use for the result,
        -: 1074:     *                which must have a non-floating-point `rep` type.
        -: 1075:     * @param __t A time point.
        -: 1076:     * @return The value of `__d` converted to type `_ToDur`.
        -: 1077:     * @since C++17
        -: 1078:     */
        -: 1079:    template<typename _ToDur, typename _Clock, typename _Dur>
        -: 1080:      [[nodiscard]] constexpr
        -: 1081:      enable_if_t<__is_duration_v<_ToDur>
        -: 1082:		    && !treat_as_floating_point_v<typename _ToDur::rep>,
        -: 1083:		  time_point<_Clock, _ToDur>>
        -: 1084:      round(const time_point<_Clock, _Dur>& __tp)
        -: 1085:      {
        -: 1086:	return time_point<_Clock, _ToDur>{
        -: 1087:	    chrono::round<_ToDur>(__tp.time_since_epoch())};
        -: 1088:      }
        -: 1089:#endif // C++17
        -: 1090:
        -: 1091:    /// @{
        -: 1092:    /// @relates time_point
        -: 1093:
        -: 1094:    /// Adjust a time point forwards by the given duration.
        -: 1095:    template<typename _Clock, typename _Dur1,
        -: 1096:	     typename _Rep2, typename _Period2>
        -: 1097:      constexpr time_point<_Clock,
        -: 1098:	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
        -: 1099:      operator+(const time_point<_Clock, _Dur1>& __lhs,
        -: 1100:		const duration<_Rep2, _Period2>& __rhs)
        -: 1101:      {
        -: 1102:	typedef duration<_Rep2, _Period2>			__dur2;
        -: 1103:	typedef typename common_type<_Dur1,__dur2>::type	__ct;
        -: 1104:	typedef time_point<_Clock, __ct>			__time_point;
        -: 1105:	return __time_point(__lhs.time_since_epoch() + __rhs);
        -: 1106:      }
        -: 1107:
        -: 1108:    /// Adjust a time point forwards by the given duration.
        -: 1109:    template<typename _Rep1, typename _Period1,
        -: 1110:	     typename _Clock, typename _Dur2>
        -: 1111:      constexpr time_point<_Clock,
        -: 1112:	typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
        -: 1113:      operator+(const duration<_Rep1, _Period1>& __lhs,
        -: 1114:		const time_point<_Clock, _Dur2>& __rhs)
        -: 1115:      {
        -: 1116:	typedef duration<_Rep1, _Period1>			__dur1;
        -: 1117:	typedef typename common_type<__dur1,_Dur2>::type	__ct;
        -: 1118:	typedef time_point<_Clock, __ct>			__time_point;
        -: 1119:	return __time_point(__rhs.time_since_epoch() + __lhs);
        -: 1120:      }
        -: 1121:
        -: 1122:    /// Adjust a time point backwards by the given duration.
        -: 1123:    template<typename _Clock, typename _Dur1,
        -: 1124:	     typename _Rep2, typename _Period2>
        -: 1125:      constexpr time_point<_Clock,
        -: 1126:	typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
        -: 1127:      operator-(const time_point<_Clock, _Dur1>& __lhs,
        -: 1128:		const duration<_Rep2, _Period2>& __rhs)
        -: 1129:      {
        -: 1130:	typedef duration<_Rep2, _Period2>			__dur2;
        -: 1131:	typedef typename common_type<_Dur1,__dur2>::type	__ct;
        -: 1132:	typedef time_point<_Clock, __ct>			__time_point;
        -: 1133:	return __time_point(__lhs.time_since_epoch() -__rhs);
        -: 1134:      }
        -: 1135:
        -: 1136:    /// The difference between two time points (as a duration)
        -: 1137:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1138:      constexpr typename common_type<_Dur1, _Dur2>::type
      123: 1139:      operator-(const time_point<_Clock, _Dur1>& __lhs,
        -: 1140:		const time_point<_Clock, _Dur2>& __rhs)
      123: 1141:      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }
------------------
_ZNSt6chronomiINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE:
function _ZNSt6chronomiINS_3_V212system_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE called 62 returned 100% blocks executed 100%
       62: 1139:      operator-(const time_point<_Clock, _Dur1>& __lhs,
        -: 1140:		const time_point<_Clock, _Dur2>& __rhs)
       62: 1141:      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }
       62: 1141-block  0
call    0 returned 62
call    1 returned 62
call    2 returned 62
------------------
_ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE:
function _ZNSt6chronomiINS_3_V212steady_clockENS_8durationIlSt5ratioILl1ELl1000000000EEEES6_EENSt11common_typeIJT0_T1_EE4typeERKNS_10time_pointIT_S8_EERKNSC_ISD_S9_EE called 61 returned 100% blocks executed 100%
       61: 1139:      operator-(const time_point<_Clock, _Dur1>& __lhs,
        -: 1140:		const time_point<_Clock, _Dur2>& __rhs)
       61: 1141:      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }
       61: 1141-block  0
call    0 returned 61
call    1 returned 61
call    2 returned 61
------------------
        -: 1142:    /// @}
        -: 1143:
        -: 1144:    /** @{
        -: 1145:     * Comparisons for time_point
        -: 1146:     * @relates chrono::time_point
        -: 1147:     */
        -: 1148:
        -: 1149:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1150:      constexpr bool
        -: 1151:      operator==(const time_point<_Clock, _Dur1>& __lhs,
        -: 1152:		 const time_point<_Clock, _Dur2>& __rhs)
        -: 1153:      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }
        -: 1154:
        -: 1155:#if __cpp_lib_three_way_comparison
        -: 1156:    template<typename _Clock, typename _Dur1,
        -: 1157:	     three_way_comparable_with<_Dur1> _Dur2>
        -: 1158:      constexpr auto
        -: 1159:      operator<=>(const time_point<_Clock, _Dur1>& __lhs,
        -: 1160:		  const time_point<_Clock, _Dur2>& __rhs)
        -: 1161:      { return __lhs.time_since_epoch() <=> __rhs.time_since_epoch(); }
        -: 1162:#else
        -: 1163:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1164:      constexpr bool
        -: 1165:      operator!=(const time_point<_Clock, _Dur1>& __lhs,
        -: 1166:		 const time_point<_Clock, _Dur2>& __rhs)
        -: 1167:      { return !(__lhs == __rhs); }
        -: 1168:#endif
        -: 1169:
        -: 1170:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1171:      constexpr bool
        -: 1172:      operator<(const time_point<_Clock, _Dur1>& __lhs,
        -: 1173:		const time_point<_Clock, _Dur2>& __rhs)
        -: 1174:      { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }
        -: 1175:
        -: 1176:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1177:      constexpr bool
        -: 1178:      operator<=(const time_point<_Clock, _Dur1>& __lhs,
        -: 1179:		 const time_point<_Clock, _Dur2>& __rhs)
        -: 1180:      { return !(__rhs < __lhs); }
        -: 1181:
        -: 1182:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1183:      constexpr bool
        -: 1184:      operator>(const time_point<_Clock, _Dur1>& __lhs,
        -: 1185:		const time_point<_Clock, _Dur2>& __rhs)
        -: 1186:      { return __rhs < __lhs; }
        -: 1187:
        -: 1188:    template<typename _Clock, typename _Dur1, typename _Dur2>
        -: 1189:      constexpr bool
        -: 1190:      operator>=(const time_point<_Clock, _Dur1>& __lhs,
        -: 1191:		 const time_point<_Clock, _Dur2>& __rhs)
        -: 1192:      { return !(__lhs < __rhs); }
        -: 1193:
        -: 1194:    /// @}
        -: 1195:    /// @} group chrono
        -: 1196:
        -: 1197:    // Clocks.
        -: 1198:
        -: 1199:    // Why nanosecond resolution as the default?
        -: 1200:    // Why have std::system_clock always count in the highest
        -: 1201:    // resolution (ie nanoseconds), even if on some OSes the low 3
        -: 1202:    // or 9 decimal digits will be always zero? This allows later
        -: 1203:    // implementations to change the system_clock::now()
        -: 1204:    // implementation any time to provide better resolution without
        -: 1205:    // changing function signature or units.
        -: 1206:
        -: 1207:    // To support the (forward) evolution of the library's defined
        -: 1208:    // clocks, wrap inside inline namespace so that the current
        -: 1209:    // defintions of system_clock, steady_clock, and
        -: 1210:    // high_resolution_clock types are uniquely mangled. This way, new
        -: 1211:    // code can use the latests clocks, while the library can contain
        -: 1212:    // compatibility definitions for previous versions.  At some
        -: 1213:    // point, when these clocks settle down, the inlined namespaces
        -: 1214:    // can be removed.  XXX GLIBCXX_ABI Deprecated
        -: 1215:_GLIBCXX_BEGIN_INLINE_ABI_NAMESPACE(_V2)
        -: 1216:
        -: 1217:    /**
        -: 1218:     *  @brief System clock.
        -: 1219:     *
        -: 1220:     *  Time returned represents wall time from the system-wide clock.
        -: 1221:     *  @ingroup chrono
        -: 1222:    */
        -: 1223:    struct system_clock
        -: 1224:    {
        -: 1225:      typedef chrono::nanoseconds				duration;
        -: 1226:      typedef duration::rep					rep;
        -: 1227:      typedef duration::period					period;
        -: 1228:      typedef chrono::time_point<system_clock, duration> 	time_point;
        -: 1229:
        -: 1230:      static_assert(system_clock::duration::min()
        -: 1231:		    < system_clock::duration::zero(),
        -: 1232:		    "a clock's minimum duration cannot be less than its epoch");
        -: 1233:
        -: 1234:      static constexpr bool is_steady = false;
        -: 1235:
        -: 1236:      static time_point
        -: 1237:      now() noexcept;
        -: 1238:
        -: 1239:      // Map to C API
        -: 1240:      static std::time_t
        -: 1241:      to_time_t(const time_point& __t) noexcept
        -: 1242:      {
        -: 1243:	return std::time_t(duration_cast<chrono::seconds>
        -: 1244:			   (__t.time_since_epoch()).count());
        -: 1245:      }
        -: 1246:
        -: 1247:      static time_point
function _ZNSt6chrono3_V212system_clock11from_time_tEl called 62 returned 100% blocks executed 100%
       62: 1248:      from_time_t(std::time_t __t) noexcept
        -: 1249:      {
        -: 1250:	typedef chrono::time_point<system_clock, seconds>	__from;
        -: 1251:	return time_point_cast<system_clock::duration>
       62: 1252:	       (__from(chrono::seconds(__t)));
       62: 1252-block  0
call    0 returned 62
call    1 returned 62
call    2 returned 62
        -: 1253:      }
        -: 1254:    };
        -: 1255:
        -: 1256:
        -: 1257:    /**
        -: 1258:     *  @brief Monotonic clock
        -: 1259:     *
        -: 1260:     *  Time returned has the property of only increasing at a uniform rate.
        -: 1261:     *  @ingroup chrono
        -: 1262:    */
        -: 1263:    struct steady_clock
        -: 1264:    {
        -: 1265:      typedef chrono::nanoseconds				duration;
        -: 1266:      typedef duration::rep					rep;
        -: 1267:      typedef duration::period					period;
        -: 1268:      typedef chrono::time_point<steady_clock, duration>	time_point;
        -: 1269:
        -: 1270:      static constexpr bool is_steady = true;
        -: 1271:
        -: 1272:      static time_point
        -: 1273:      now() noexcept;
        -: 1274:    };
        -: 1275:
        -: 1276:
        -: 1277:    /**
        -: 1278:     *  @brief Highest-resolution clock
        -: 1279:     *
        -: 1280:     *  This is the clock "with the shortest tick period." Alias to
        -: 1281:     *  std::system_clock until higher-than-nanosecond definitions
        -: 1282:     *  become feasible.
        -: 1283:     *  @ingroup chrono
        -: 1284:    */
        -: 1285:    using high_resolution_clock = system_clock;
        -: 1286:
        -: 1287:_GLIBCXX_END_INLINE_ABI_NAMESPACE(_V2)
        -: 1288:
        -: 1289:#if __cplusplus >= 202002L
        -: 1290:    /// @addtogroup chrono
        -: 1291:    /// @{
        -: 1292:    template<typename _Duration>
        -: 1293:      using sys_time = time_point<system_clock, _Duration>;
        -: 1294:    using sys_seconds = sys_time<seconds>;
        -: 1295:    using sys_days = sys_time<days>;
        -: 1296:
        -: 1297:    using file_clock = ::std::filesystem::__file_clock;
        -: 1298:
        -: 1299:    template<typename _Duration>
        -: 1300:      using file_time = time_point<file_clock, _Duration>;
        -: 1301:
        -: 1302:    template<> struct is_clock<system_clock> : true_type { };
        -: 1303:    template<> struct is_clock<steady_clock> : true_type { };
        -: 1304:    template<> struct is_clock<file_clock> : true_type { };
        -: 1305:
        -: 1306:    template<> inline constexpr bool is_clock_v<system_clock> = true;
        -: 1307:    template<> inline constexpr bool is_clock_v<steady_clock> = true;
        -: 1308:    template<> inline constexpr bool is_clock_v<file_clock> = true;
        -: 1309:    /// @}
        -: 1310:#endif // C++20
        -: 1311:  } // namespace chrono
        -: 1312:
        -: 1313:#if __cplusplus >= 201402L
        -: 1314:#define __cpp_lib_chrono_udls 201304L
        -: 1315:
        -: 1316:  inline namespace literals
        -: 1317:  {
        -: 1318:  /** ISO C++ 2014  namespace for suffixes for duration literals.
        -: 1319:   *
        -: 1320:   * These suffixes can be used to create `chrono::duration` values with
        -: 1321:   * tick periods of hours, minutes, seconds, milliseconds, microseconds
        -: 1322:   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written
        -: 1323:   * as `5s` after making the suffix visible in the current scope.
        -: 1324:   * The suffixes can be made visible by a using-directive or
        -: 1325:   * using-declaration such as:
        -: 1326:   *  - `using namespace std::chrono_literals;`
        -: 1327:   *  - `using namespace std::literals;`
        -: 1328:   *  - `using namespace std::chrono;`
        -: 1329:   *  - `using namespace std;`
        -: 1330:   *  - `using std::chrono_literals::operator""s;`
        -: 1331:   *
        -: 1332:   * The result of these suffixes on an integer literal is one of the
        -: 1333:   * standard typedefs such as `std::chrono::hours`.
        -: 1334:   * The result on a floating-point literal is a duration type with the
        -: 1335:   * specified tick period and an unspecified floating-point representation,
        -: 1336:   * for example `1.5e2ms` might be equivalent to
        -: 1337:   * `chrono::duration<long double, chrono::milli>(1.5e2)`.
        -: 1338:   *
        -: 1339:   * @since C+14
        -: 1340:   * @ingroup chrono
        -: 1341:   */
        -: 1342:  inline namespace chrono_literals
        -: 1343:  {
        -: 1344:    /// @addtogroup chrono
        -: 1345:    /// @{
        -: 1346:
        -: 1347:#pragma GCC diagnostic push
        -: 1348:#pragma GCC diagnostic ignored "-Wliteral-suffix"
        -: 1349:    /// @cond undocumented
        -: 1350:    template<typename _Dur, char... _Digits>
        -: 1351:      constexpr _Dur __check_overflow()
        -: 1352:      {
        -: 1353:	using _Val = __parse_int::_Parse_int<_Digits...>;
        -: 1354:	constexpr typename _Dur::rep __repval = _Val::value;
        -: 1355:	static_assert(__repval >= 0 && __repval == _Val::value,
        -: 1356:		      "literal value cannot be represented by duration type");
        -: 1357:	return _Dur(__repval);
        -: 1358:      }
        -: 1359:    /// @endcond
        -: 1360:
        -: 1361:    /// Literal suffix for durations representing non-integer hours
        -: 1362:    constexpr chrono::duration<long double, ratio<3600,1>>
        -: 1363:    operator""h(long double __hours)
        -: 1364:    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }
        -: 1365:
        -: 1366:    /// Literal suffix for durations of type `std::chrono::hours`
        -: 1367:    template <char... _Digits>
        -: 1368:      constexpr chrono::hours
        -: 1369:      operator""h()
        -: 1370:      { return __check_overflow<chrono::hours, _Digits...>(); }
        -: 1371:
        -: 1372:    /// Literal suffix for durations representing non-integer minutes
        -: 1373:    constexpr chrono::duration<long double, ratio<60,1>>
        -: 1374:    operator""min(long double __mins)
        -: 1375:    { return chrono::duration<long double, ratio<60,1>>{__mins}; }
        -: 1376:
        -: 1377:    /// Literal suffix for durations of type `std::chrono::minutes`
        -: 1378:    template <char... _Digits>
        -: 1379:      constexpr chrono::minutes
        -: 1380:      operator""min()
        -: 1381:      { return __check_overflow<chrono::minutes, _Digits...>(); }
        -: 1382:
        -: 1383:    /// Literal suffix for durations representing non-integer seconds
        -: 1384:    constexpr chrono::duration<long double>
        -: 1385:    operator""s(long double __secs)
        -: 1386:    { return chrono::duration<long double>{__secs}; }
        -: 1387:
        -: 1388:    /// Literal suffix for durations of type `std::chrono::seconds`
        -: 1389:    template <char... _Digits>
        -: 1390:      constexpr chrono::seconds
        -: 1391:      operator""s()
        -: 1392:      { return __check_overflow<chrono::seconds, _Digits...>(); }
        -: 1393:
        -: 1394:    /// Literal suffix for durations representing non-integer milliseconds
        -: 1395:    constexpr chrono::duration<long double, milli>
        -: 1396:    operator""ms(long double __msecs)
        -: 1397:    { return chrono::duration<long double, milli>{__msecs}; }
        -: 1398:
        -: 1399:    /// Literal suffix for durations of type `std::chrono::milliseconds`
        -: 1400:    template <char... _Digits>
        -: 1401:      constexpr chrono::milliseconds
        -: 1402:      operator""ms()
        -: 1403:      { return __check_overflow<chrono::milliseconds, _Digits...>(); }
        -: 1404:
        -: 1405:    /// Literal suffix for durations representing non-integer microseconds
        -: 1406:    constexpr chrono::duration<long double, micro>
        -: 1407:    operator""us(long double __usecs)
        -: 1408:    { return chrono::duration<long double, micro>{__usecs}; }
        -: 1409:
        -: 1410:    /// Literal suffix for durations of type `std::chrono::microseconds`
        -: 1411:    template <char... _Digits>
        -: 1412:      constexpr chrono::microseconds
        -: 1413:      operator""us()
        -: 1414:      { return __check_overflow<chrono::microseconds, _Digits...>(); }
        -: 1415:
        -: 1416:    /// Literal suffix for durations representing non-integer nanoseconds
        -: 1417:    constexpr chrono::duration<long double, nano>
        -: 1418:    operator""ns(long double __nsecs)
        -: 1419:    { return chrono::duration<long double, nano>{__nsecs}; }
        -: 1420:
        -: 1421:    /// Literal suffix for durations of type `std::chrono::nanoseconds`
        -: 1422:    template <char... _Digits>
        -: 1423:      constexpr chrono::nanoseconds
        -: 1424:      operator""ns()
        -: 1425:      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }
        -: 1426:
        -: 1427:#pragma GCC diagnostic pop
        -: 1428:    /// @}
        -: 1429:  } // inline namespace chrono_literals
        -: 1430:  } // inline namespace literals
        -: 1431:
        -: 1432:  namespace chrono
        -: 1433:  {
        -: 1434:    using namespace literals::chrono_literals;
        -: 1435:  } // namespace chrono
        -: 1436:#endif // C++14
        -: 1437:
        -: 1438:#if __cplusplus >= 201703L
        -: 1439:  namespace filesystem
        -: 1440:  {
        -: 1441:    struct __file_clock
        -: 1442:    {
        -: 1443:      using duration                  = chrono::nanoseconds;
        -: 1444:      using rep                       = duration::rep;
        -: 1445:      using period                    = duration::period;
        -: 1446:      using time_point                = chrono::time_point<__file_clock>;
        -: 1447:      static constexpr bool is_steady = false;
        -: 1448:
        -: 1449:      static time_point
        -: 1450:      now() noexcept
        -: 1451:      { return _S_from_sys(chrono::system_clock::now()); }
        -: 1452:
        -: 1453:#if __cplusplus > 201703L
        -: 1454:      template<typename _Dur>
        -: 1455:	static
        -: 1456:	chrono::file_time<_Dur>
        -: 1457:	from_sys(const chrono::sys_time<_Dur>& __t) noexcept
        -: 1458:	{ return _S_from_sys(__t); }
        -: 1459:
        -: 1460:      // For internal use only
        -: 1461:      template<typename _Dur>
        -: 1462:	static
        -: 1463:	chrono::sys_time<_Dur>
        -: 1464:	to_sys(const chrono::file_time<_Dur>& __t) noexcept
        -: 1465:	{ return _S_to_sys(__t); }
        -: 1466:#endif // C++20
        -: 1467:
        -: 1468:    private:
        -: 1469:      using __sys_clock = chrono::system_clock;
        -: 1470:
        -: 1471:      // This clock's (unspecified) epoch is 2174-01-01 00:00:00 UTC.
        -: 1472:      // A signed 64-bit duration with nanosecond resolution gives roughly
        -: 1473:      // +/- 292 years, which covers the 1901-2446 date range for ext4.
        -: 1474:      static constexpr chrono::seconds _S_epoch_diff{6437664000};
        -: 1475:
        -: 1476:    protected:
        -: 1477:      // For internal use only
        -: 1478:      template<typename _Dur>
        -: 1479:	static
        -: 1480:	chrono::time_point<__file_clock, _Dur>
        -: 1481:	_S_from_sys(const chrono::time_point<__sys_clock, _Dur>& __t) noexcept
        -: 1482:	{
        -: 1483:	  using __file_time = chrono::time_point<__file_clock, _Dur>;
        -: 1484:	  return __file_time{__t.time_since_epoch()} - _S_epoch_diff;
        -: 1485:	}
        -: 1486:
        -: 1487:      // For internal use only
        -: 1488:      template<typename _Dur>
        -: 1489:	static
        -: 1490:	chrono::time_point<__sys_clock, _Dur>
        -: 1491:	_S_to_sys(const chrono::time_point<__file_clock, _Dur>& __t) noexcept
        -: 1492:	{
        -: 1493:	  using __sys_time = chrono::time_point<__sys_clock, _Dur>;
        -: 1494:	  return __sys_time{__t.time_since_epoch()} + _S_epoch_diff;
        -: 1495:	}
        -: 1496:    };
        -: 1497:  } // namespace filesystem
        -: 1498:#endif // C++17
        -: 1499:
        -: 1500:_GLIBCXX_END_NAMESPACE_VERSION
        -: 1501:} // namespace std
        -: 1502:
        -: 1503:#endif // C++11
        -: 1504:
        -: 1505:#endif //_GLIBCXX_CHRONO_H
